// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: orders.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const confirmOrderByID = `-- name: ConfirmOrderByID :one
UPDATE orders
SET status     = 'packaging',
    updated_at = now()
WHERE id = $1
  AND seller_id = $2 RETURNING id, code, buyer_id, seller_id, items_subtotal, delivery_fee, total_amount, status, payment_method, type, note, is_packaged, packaging_image_urls, canceled_by, canceled_reason, created_at, updated_at, completed_at
`

type ConfirmOrderByIDParams struct {
	OrderID  uuid.UUID `json:"order_id"`
	SellerID string    `json:"seller_id"`
}

func (q *Queries) ConfirmOrderByID(ctx context.Context, arg ConfirmOrderByIDParams) (Order, error) {
	row := q.db.QueryRow(ctx, confirmOrderByID, arg.OrderID, arg.SellerID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.BuyerID,
		&i.SellerID,
		&i.ItemsSubtotal,
		&i.DeliveryFee,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.Type,
		&i.Note,
		&i.IsPackaged,
		&i.PackagingImageURLs,
		&i.CanceledBy,
		&i.CanceledReason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (id,
                    code,
                    buyer_id,
                    seller_id,
                    items_subtotal,
                    delivery_fee,
                    total_amount,
                    status,
                    payment_method,
                    type,
                    note)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id, code, buyer_id, seller_id, items_subtotal, delivery_fee, total_amount, status, payment_method, type, note, is_packaged, packaging_image_urls, canceled_by, canceled_reason, created_at, updated_at, completed_at
`

type CreateOrderParams struct {
	ID            uuid.UUID     `json:"id"`
	Code          string        `json:"code"`
	BuyerID       string        `json:"buyer_id"`
	SellerID      string        `json:"seller_id"`
	ItemsSubtotal int64         `json:"items_subtotal"`
	DeliveryFee   int64         `json:"delivery_fee"`
	TotalAmount   int64         `json:"total_amount"`
	Status        OrderStatus   `json:"status"`
	PaymentMethod PaymentMethod `json:"payment_method"`
	Type          OrderType     `json:"type"`
	Note          *string       `json:"note"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.ID,
		arg.Code,
		arg.BuyerID,
		arg.SellerID,
		arg.ItemsSubtotal,
		arg.DeliveryFee,
		arg.TotalAmount,
		arg.Status,
		arg.PaymentMethod,
		arg.Type,
		arg.Note,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.BuyerID,
		&i.SellerID,
		&i.ItemsSubtotal,
		&i.DeliveryFee,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.Type,
		&i.Note,
		&i.IsPackaged,
		&i.PackagingImageURLs,
		&i.CanceledBy,
		&i.CanceledReason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, code, buyer_id, seller_id, items_subtotal, delivery_fee, total_amount, status, payment_method, type, note, is_packaged, packaging_image_urls, canceled_by, canceled_reason, created_at, updated_at, completed_at
FROM orders
WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.BuyerID,
		&i.SellerID,
		&i.ItemsSubtotal,
		&i.DeliveryFee,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.Type,
		&i.Note,
		&i.IsPackaged,
		&i.PackagingImageURLs,
		&i.CanceledBy,
		&i.CanceledReason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getOrderDetails = `-- name: GetOrderDetails :one
SELECT od.id,
       o.id      AS order_id,
       o.code    AS order_code,
       o.buyer_id,
       o.seller_id,
       o.items_subtotal,
       o.status  AS order_status,
       od.status as delivery_status,
       od.overall_status,
       od.from_delivery_id,
       od.to_delivery_id,
       od.delivery_tracking_code,
       od.expected_delivery_time,
       od.created_at,
       od.updated_at
FROM order_deliveries od
         JOIN orders o ON od.order_id = o.id
WHERE o.id = $1
  AND od.status IS NOT NULL
  AND od.delivery_tracking_code IS NOT NULL
ORDER BY od.created_at DESC LIMIT 1
`

type GetOrderDetailsRow struct {
	ID                   int64                     `json:"id"`
	OrderID              uuid.UUID                 `json:"order_id"`
	OrderCode            string                    `json:"order_code"`
	BuyerID              string                    `json:"buyer_id"`
	SellerID             string                    `json:"seller_id"`
	ItemsSubtotal        int64                     `json:"items_subtotal"`
	OrderStatus          OrderStatus               `json:"order_status"`
	DeliveryStatus       *string                   `json:"delivery_status"`
	OverallStatus        NullDeliveryOverralStatus `json:"overall_status"`
	FromDeliveryID       int64                     `json:"from_delivery_id"`
	ToDeliveryID         int64                     `json:"to_delivery_id"`
	DeliveryTrackingCode *string                   `json:"delivery_tracking_code"`
	ExpectedDeliveryTime time.Time                 `json:"expected_delivery_time"`
	CreatedAt            time.Time                 `json:"created_at"`
	UpdatedAt            time.Time                 `json:"updated_at"`
}

func (q *Queries) GetOrderDetails(ctx context.Context, id uuid.UUID) (GetOrderDetailsRow, error) {
	row := q.db.QueryRow(ctx, getOrderDetails, id)
	var i GetOrderDetailsRow
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.OrderCode,
		&i.BuyerID,
		&i.SellerID,
		&i.ItemsSubtotal,
		&i.OrderStatus,
		&i.DeliveryStatus,
		&i.OverallStatus,
		&i.FromDeliveryID,
		&i.ToDeliveryID,
		&i.DeliveryTrackingCode,
		&i.ExpectedDeliveryTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrdersToAutoComplete = `-- name: GetOrdersToAutoComplete :many
SELECT o.id, o.code, o.buyer_id, o.seller_id, o.items_subtotal, o.delivery_fee, o.total_amount, o.status, o.payment_method, o.type, o.note, o.is_packaged, o.packaging_image_urls, o.canceled_by, o.canceled_reason, o.created_at, o.updated_at, o.completed_at
FROM orders o
WHERE o.status = 'delivered'
  AND o.updated_at < $1
ORDER BY o.updated_at ASC
`

func (q *Queries) GetOrdersToAutoComplete(ctx context.Context, updatedAt time.Time) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersToAutoComplete, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.BuyerID,
			&i.SellerID,
			&i.ItemsSubtotal,
			&i.DeliveryFee,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentMethod,
			&i.Type,
			&i.Note,
			&i.IsPackaged,
			&i.PackagingImageURLs,
			&i.CanceledBy,
			&i.CanceledReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemberOrders = `-- name: ListMemberOrders :many
SELECT id, code, buyer_id, seller_id, items_subtotal, delivery_fee, total_amount, status, payment_method, type, note, is_packaged, packaging_image_urls, canceled_by, canceled_reason, created_at, updated_at, completed_at
FROM orders
WHERE (buyer_id = $1 OR (type = 'exchange' AND seller_id = $1))
  AND status = COALESCE($2::order_status, status)
ORDER BY updated_at DESC, created_at DESC
`

type ListMemberOrdersParams struct {
	BuyerID string          `json:"buyer_id"`
	Status  NullOrderStatus `json:"status"`
}

func (q *Queries) ListMemberOrders(ctx context.Context, arg ListMemberOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listMemberOrders, arg.BuyerID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.BuyerID,
			&i.SellerID,
			&i.ItemsSubtotal,
			&i.DeliveryFee,
			&i.TotalAmount,
			&i.Status,
			&i.PaymentMethod,
			&i.Type,
			&i.Note,
			&i.IsPackaged,
			&i.PackagingImageURLs,
			&i.CanceledBy,
			&i.CanceledReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET is_packaged          = COALESCE($1, is_packaged),
    packaging_image_urls = COALESCE($2, packaging_image_urls),
    status               = COALESCE($3, status),
    canceled_by          = COALESCE($4, canceled_by),
    canceled_reason      = COALESCE($5, canceled_reason),
    completed_at         = COALESCE($6, completed_at),
    updated_at           = now()
WHERE id = $7 RETURNING id, code, buyer_id, seller_id, items_subtotal, delivery_fee, total_amount, status, payment_method, type, note, is_packaged, packaging_image_urls, canceled_by, canceled_reason, created_at, updated_at, completed_at
`

type UpdateOrderParams struct {
	IsPackaged         *bool           `json:"is_packaged"`
	PackagingImageURLs []string        `json:"packaging_image_urls"`
	Status             NullOrderStatus `json:"status"`
	CanceledBy         *string         `json:"canceled_by"`
	CanceledReason     *string         `json:"canceled_reason"`
	CompletedAt        *time.Time      `json:"completed_at"`
	OrderID            uuid.UUID       `json:"order_id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.IsPackaged,
		arg.PackagingImageURLs,
		arg.Status,
		arg.CanceledBy,
		arg.CanceledReason,
		arg.CompletedAt,
		arg.OrderID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.BuyerID,
		&i.SellerID,
		&i.ItemsSubtotal,
		&i.DeliveryFee,
		&i.TotalAmount,
		&i.Status,
		&i.PaymentMethod,
		&i.Type,
		&i.Note,
		&i.IsPackaged,
		&i.PackagingImageURLs,
		&i.CanceledBy,
		&i.CanceledReason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}
