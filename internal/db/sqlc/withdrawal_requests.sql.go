// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: withdrawal_requests.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createWithdrawalRequest = `-- name: CreateWithdrawalRequest :one
INSERT INTO withdrawal_requests (id,
                                 user_id,
                                 bank_account_id,
                                 amount,
                                 wallet_entry_id)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, bank_account_id, amount, status, processed_by, processed_at, rejected_reason, transaction_reference, wallet_entry_id, created_at, updated_at, completed_at
`

type CreateWithdrawalRequestParams struct {
	ID            uuid.UUID `json:"id"`
	UserID        string    `json:"user_id"`
	BankAccountID uuid.UUID `json:"bank_account_id"`
	Amount        int64     `json:"amount"`
	WalletEntryID *int64    `json:"wallet_entry_id"`
}

func (q *Queries) CreateWithdrawalRequest(ctx context.Context, arg CreateWithdrawalRequestParams) (WithdrawalRequest, error) {
	row := q.db.QueryRow(ctx, createWithdrawalRequest,
		arg.ID,
		arg.UserID,
		arg.BankAccountID,
		arg.Amount,
		arg.WalletEntryID,
	)
	var i WithdrawalRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BankAccountID,
		&i.Amount,
		&i.Status,
		&i.ProcessedBy,
		&i.ProcessedAt,
		&i.RejectedReason,
		&i.TransactionReference,
		&i.WalletEntryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getWithdrawalRequest = `-- name: GetWithdrawalRequest :one
SELECT wr.id, wr.user_id, wr.bank_account_id, wr.amount, wr.status, wr.processed_by, wr.processed_at, wr.rejected_reason, wr.transaction_reference, wr.wallet_entry_id, wr.created_at, wr.updated_at, wr.completed_at,
       uba.id, uba.user_id, uba.account_name, uba.account_number, uba.bank_code, uba.bank_name, uba.bank_short_name, uba.created_at, uba.updated_at
FROM withdrawal_requests wr
         LEFT JOIN user_bank_accounts uba ON wr.bank_account_id = uba.id
WHERE wr.id = $1
`

type GetWithdrawalRequestRow struct {
	WithdrawalRequest WithdrawalRequest `json:"withdrawal_request"`
	UserBankAccount   UserBankAccount   `json:"user_bank_account"`
}

func (q *Queries) GetWithdrawalRequest(ctx context.Context, id uuid.UUID) (GetWithdrawalRequestRow, error) {
	row := q.db.QueryRow(ctx, getWithdrawalRequest, id)
	var i GetWithdrawalRequestRow
	err := row.Scan(
		&i.WithdrawalRequest.ID,
		&i.WithdrawalRequest.UserID,
		&i.WithdrawalRequest.BankAccountID,
		&i.WithdrawalRequest.Amount,
		&i.WithdrawalRequest.Status,
		&i.WithdrawalRequest.ProcessedBy,
		&i.WithdrawalRequest.ProcessedAt,
		&i.WithdrawalRequest.RejectedReason,
		&i.WithdrawalRequest.TransactionReference,
		&i.WithdrawalRequest.WalletEntryID,
		&i.WithdrawalRequest.CreatedAt,
		&i.WithdrawalRequest.UpdatedAt,
		&i.WithdrawalRequest.CompletedAt,
		&i.UserBankAccount.ID,
		&i.UserBankAccount.UserID,
		&i.UserBankAccount.AccountName,
		&i.UserBankAccount.AccountNumber,
		&i.UserBankAccount.BankCode,
		&i.UserBankAccount.BankName,
		&i.UserBankAccount.BankShortName,
		&i.UserBankAccount.CreatedAt,
		&i.UserBankAccount.UpdatedAt,
	)
	return i, err
}

const listUserWithdrawalRequests = `-- name: ListUserWithdrawalRequests :many
SELECT wr.id, wr.user_id, wr.bank_account_id, wr.amount, wr.status, wr.processed_by, wr.processed_at, wr.rejected_reason, wr.transaction_reference, wr.wallet_entry_id, wr.created_at, wr.updated_at, wr.completed_at,
       uba.id, uba.user_id, uba.account_name, uba.account_number, uba.bank_code, uba.bank_name, uba.bank_short_name, uba.created_at, uba.updated_at
FROM withdrawal_requests wr
         LEFT JOIN user_bank_accounts uba ON wr.bank_account_id = uba.id
WHERE wr.user_id = $1
  AND wr.status = COALESCE($2, wr.status)
ORDER BY wr.created_at DESC
`

type ListUserWithdrawalRequestsParams struct {
	UserID string                      `json:"user_id"`
	Status NullWithdrawalRequestStatus `json:"status"`
}

type ListUserWithdrawalRequestsRow struct {
	WithdrawalRequest WithdrawalRequest `json:"withdrawal_request"`
	UserBankAccount   UserBankAccount   `json:"user_bank_account"`
}

func (q *Queries) ListUserWithdrawalRequests(ctx context.Context, arg ListUserWithdrawalRequestsParams) ([]ListUserWithdrawalRequestsRow, error) {
	rows, err := q.db.Query(ctx, listUserWithdrawalRequests, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserWithdrawalRequestsRow{}
	for rows.Next() {
		var i ListUserWithdrawalRequestsRow
		if err := rows.Scan(
			&i.WithdrawalRequest.ID,
			&i.WithdrawalRequest.UserID,
			&i.WithdrawalRequest.BankAccountID,
			&i.WithdrawalRequest.Amount,
			&i.WithdrawalRequest.Status,
			&i.WithdrawalRequest.ProcessedBy,
			&i.WithdrawalRequest.ProcessedAt,
			&i.WithdrawalRequest.RejectedReason,
			&i.WithdrawalRequest.TransactionReference,
			&i.WithdrawalRequest.WalletEntryID,
			&i.WithdrawalRequest.CreatedAt,
			&i.WithdrawalRequest.UpdatedAt,
			&i.WithdrawalRequest.CompletedAt,
			&i.UserBankAccount.ID,
			&i.UserBankAccount.UserID,
			&i.UserBankAccount.AccountName,
			&i.UserBankAccount.AccountNumber,
			&i.UserBankAccount.BankCode,
			&i.UserBankAccount.BankName,
			&i.UserBankAccount.BankShortName,
			&i.UserBankAccount.CreatedAt,
			&i.UserBankAccount.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWithdrawalRequests = `-- name: ListWithdrawalRequests :many
SELECT wr.id, wr.user_id, wr.bank_account_id, wr.amount, wr.status, wr.processed_by, wr.processed_at, wr.rejected_reason, wr.transaction_reference, wr.wallet_entry_id, wr.created_at, wr.updated_at, wr.completed_at,
       uba.id, uba.user_id, uba.account_name, uba.account_number, uba.bank_code, uba.bank_name, uba.bank_short_name, uba.created_at, uba.updated_at
FROM withdrawal_requests wr
         LEFT JOIN user_bank_accounts uba ON wr.bank_account_id = uba.id
WHERE wr.status = COALESCE($1, wr.status)
ORDER BY wr.created_at DESC
`

type ListWithdrawalRequestsRow struct {
	WithdrawalRequest WithdrawalRequest `json:"withdrawal_request"`
	UserBankAccount   UserBankAccount   `json:"user_bank_account"`
}

func (q *Queries) ListWithdrawalRequests(ctx context.Context, status NullWithdrawalRequestStatus) ([]ListWithdrawalRequestsRow, error) {
	rows, err := q.db.Query(ctx, listWithdrawalRequests, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWithdrawalRequestsRow{}
	for rows.Next() {
		var i ListWithdrawalRequestsRow
		if err := rows.Scan(
			&i.WithdrawalRequest.ID,
			&i.WithdrawalRequest.UserID,
			&i.WithdrawalRequest.BankAccountID,
			&i.WithdrawalRequest.Amount,
			&i.WithdrawalRequest.Status,
			&i.WithdrawalRequest.ProcessedBy,
			&i.WithdrawalRequest.ProcessedAt,
			&i.WithdrawalRequest.RejectedReason,
			&i.WithdrawalRequest.TransactionReference,
			&i.WithdrawalRequest.WalletEntryID,
			&i.WithdrawalRequest.CreatedAt,
			&i.WithdrawalRequest.UpdatedAt,
			&i.WithdrawalRequest.CompletedAt,
			&i.UserBankAccount.ID,
			&i.UserBankAccount.UserID,
			&i.UserBankAccount.AccountName,
			&i.UserBankAccount.AccountNumber,
			&i.UserBankAccount.BankCode,
			&i.UserBankAccount.BankName,
			&i.UserBankAccount.BankShortName,
			&i.UserBankAccount.CreatedAt,
			&i.UserBankAccount.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWithdrawalRequest = `-- name: UpdateWithdrawalRequest :one
UPDATE withdrawal_requests
SET status                = COALESCE($1, status),
    processed_by          = COALESCE($2, processed_by),
    processed_at          = COALESCE($3, processed_at),
    rejected_reason       = COALESCE($4, rejected_reason),
    transaction_reference = COALESCE($5, transaction_reference),
    completed_at          = COALESCE($6, completed_at),
    updated_at            = NOW()
WHERE id = $7 RETURNING id, user_id, bank_account_id, amount, status, processed_by, processed_at, rejected_reason, transaction_reference, wallet_entry_id, created_at, updated_at, completed_at
`

type UpdateWithdrawalRequestParams struct {
	Status               NullWithdrawalRequestStatus `json:"status"`
	ProcessedBy          *string                     `json:"processed_by"`
	ProcessedAt          *time.Time                  `json:"processed_at"`
	RejectedReason       *string                     `json:"rejected_reason"`
	TransactionReference *string                     `json:"transaction_reference"`
	CompletedAt          *time.Time                  `json:"completed_at"`
	ID                   uuid.UUID                   `json:"id"`
}

func (q *Queries) UpdateWithdrawalRequest(ctx context.Context, arg UpdateWithdrawalRequestParams) (WithdrawalRequest, error) {
	row := q.db.QueryRow(ctx, updateWithdrawalRequest,
		arg.Status,
		arg.ProcessedBy,
		arg.ProcessedAt,
		arg.RejectedReason,
		arg.TransactionReference,
		arg.CompletedAt,
		arg.ID,
	)
	var i WithdrawalRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BankAccountID,
		&i.Amount,
		&i.Status,
		&i.ProcessedBy,
		&i.ProcessedAt,
		&i.RejectedReason,
		&i.TransactionReference,
		&i.WalletEntryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}
