// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: withdrawal_requests.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createWithdrawalRequest = `-- name: CreateWithdrawalRequest :one
INSERT INTO withdrawal_requests (id,
                                 user_id,
                                 bank_account_id,
                                 amount,
                                 wallet_entry_id)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, bank_account_id, amount, status, processed_by, processed_at, rejected_reason, transaction_reference, wallet_entry_id, created_at, updated_at, completed_at
`

type CreateWithdrawalRequestParams struct {
	ID            uuid.UUID `json:"id"`
	UserID        string    `json:"user_id"`
	BankAccountID uuid.UUID `json:"bank_account_id"`
	Amount        int64     `json:"amount"`
	WalletEntryID *int64    `json:"wallet_entry_id"`
}

func (q *Queries) CreateWithdrawalRequest(ctx context.Context, arg CreateWithdrawalRequestParams) (WithdrawalRequest, error) {
	row := q.db.QueryRow(ctx, createWithdrawalRequest,
		arg.ID,
		arg.UserID,
		arg.BankAccountID,
		arg.Amount,
		arg.WalletEntryID,
	)
	var i WithdrawalRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BankAccountID,
		&i.Amount,
		&i.Status,
		&i.ProcessedBy,
		&i.ProcessedAt,
		&i.RejectedReason,
		&i.TransactionReference,
		&i.WalletEntryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listUserWithdrawalRequests = `-- name: ListUserWithdrawalRequests :many
SELECT wr.id, wr.user_id, wr.bank_account_id, wr.amount, wr.status, wr.processed_by, wr.processed_at, wr.rejected_reason, wr.transaction_reference, wr.wallet_entry_id, wr.created_at, wr.updated_at, wr.completed_at,
       uba.id, uba.user_id, uba.account_name, uba.account_number, uba.bank_code, uba.bank_name, uba.bank_short_name, uba.created_at, uba.updated_at
FROM withdrawal_requests wr
         LEFT JOIN user_bank_accounts uba ON wr.bank_account_id = uba.id
WHERE wr.user_id = $1
  AND wr.status = COALESCE($2, wr.status)
ORDER BY wr.created_at DESC
`

type ListUserWithdrawalRequestsParams struct {
	UserID string                      `json:"user_id"`
	Status NullWithdrawalRequestStatus `json:"status"`
}

type ListUserWithdrawalRequestsRow struct {
	WithdrawalRequest WithdrawalRequest `json:"withdrawal_request"`
	UserBankAccount   UserBankAccount   `json:"user_bank_account"`
}

func (q *Queries) ListUserWithdrawalRequests(ctx context.Context, arg ListUserWithdrawalRequestsParams) ([]ListUserWithdrawalRequestsRow, error) {
	rows, err := q.db.Query(ctx, listUserWithdrawalRequests, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserWithdrawalRequestsRow{}
	for rows.Next() {
		var i ListUserWithdrawalRequestsRow
		if err := rows.Scan(
			&i.WithdrawalRequest.ID,
			&i.WithdrawalRequest.UserID,
			&i.WithdrawalRequest.BankAccountID,
			&i.WithdrawalRequest.Amount,
			&i.WithdrawalRequest.Status,
			&i.WithdrawalRequest.ProcessedBy,
			&i.WithdrawalRequest.ProcessedAt,
			&i.WithdrawalRequest.RejectedReason,
			&i.WithdrawalRequest.TransactionReference,
			&i.WithdrawalRequest.WalletEntryID,
			&i.WithdrawalRequest.CreatedAt,
			&i.WithdrawalRequest.UpdatedAt,
			&i.WithdrawalRequest.CompletedAt,
			&i.UserBankAccount.ID,
			&i.UserBankAccount.UserID,
			&i.UserBankAccount.AccountName,
			&i.UserBankAccount.AccountNumber,
			&i.UserBankAccount.BankCode,
			&i.UserBankAccount.BankName,
			&i.UserBankAccount.BankShortName,
			&i.UserBankAccount.CreatedAt,
			&i.UserBankAccount.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
