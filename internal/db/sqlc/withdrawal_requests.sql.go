// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: withdrawal_requests.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createWithdrawalRequest = `-- name: CreateWithdrawalRequest :one
INSERT INTO withdrawal_requests (id,
                                 user_id,
                                 bank_account_id,
                                 amount,
                                 wallet_entry_id)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, bank_account_id, amount, status, processed_by, processed_at, rejected_reason, transaction_reference, wallet_entry_id, created_at, updated_at, completed_at
`

type CreateWithdrawalRequestParams struct {
	ID            uuid.UUID `json:"id"`
	UserID        string    `json:"user_id"`
	BankAccountID uuid.UUID `json:"bank_account_id"`
	Amount        int64     `json:"amount"`
	WalletEntryID *int64    `json:"wallet_entry_id"`
}

func (q *Queries) CreateWithdrawalRequest(ctx context.Context, arg CreateWithdrawalRequestParams) (WithdrawalRequest, error) {
	row := q.db.QueryRow(ctx, createWithdrawalRequest,
		arg.ID,
		arg.UserID,
		arg.BankAccountID,
		arg.Amount,
		arg.WalletEntryID,
	)
	var i WithdrawalRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BankAccountID,
		&i.Amount,
		&i.Status,
		&i.ProcessedBy,
		&i.ProcessedAt,
		&i.RejectedReason,
		&i.TransactionReference,
		&i.WalletEntryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listUserWithdrawalRequests = `-- name: ListUserWithdrawalRequests :many
SELECT
    wr.id, wr.user_id, wr.bank_account_id, wr.amount, wr.status, wr.processed_by, wr.processed_at, wr.rejected_reason, wr.transaction_reference, wr.wallet_entry_id, wr.created_at, wr.updated_at, wr.completed_at,
    uba.account_name,
    uba.account_number,
    uba.bank_short_name
FROM withdrawal_requests wr
         LEFT JOIN user_bank_accounts uba ON wr.bank_account_id = uba.id
WHERE wr.user_id = $1
ORDER BY wr.created_at DESC
`

type ListUserWithdrawalRequestsRow struct {
	ID                   uuid.UUID               `json:"id"`
	UserID               string                  `json:"user_id"`
	BankAccountID        uuid.UUID               `json:"bank_account_id"`
	Amount               int64                   `json:"amount"`
	Status               WithdrawalRequestStatus `json:"status"`
	ProcessedBy          *string                 `json:"processed_by"`
	ProcessedAt          *time.Time              `json:"processed_at"`
	RejectedReason       *string                 `json:"rejected_reason"`
	TransactionReference *string                 `json:"transaction_reference"`
	WalletEntryID        *int64                  `json:"wallet_entry_id"`
	CreatedAt            time.Time               `json:"created_at"`
	UpdatedAt            time.Time               `json:"updated_at"`
	CompletedAt          *time.Time              `json:"completed_at"`
	AccountName          *string                 `json:"account_name"`
	AccountNumber        *string                 `json:"account_number"`
	BankShortName        *string                 `json:"bank_short_name"`
}

func (q *Queries) ListUserWithdrawalRequests(ctx context.Context, userID string) ([]ListUserWithdrawalRequestsRow, error) {
	rows, err := q.db.Query(ctx, listUserWithdrawalRequests, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserWithdrawalRequestsRow{}
	for rows.Next() {
		var i ListUserWithdrawalRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BankAccountID,
			&i.Amount,
			&i.Status,
			&i.ProcessedBy,
			&i.ProcessedAt,
			&i.RejectedReason,
			&i.TransactionReference,
			&i.WalletEntryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.AccountName,
			&i.AccountNumber,
			&i.BankShortName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
