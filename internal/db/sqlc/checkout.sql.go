// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: checkout.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCheckoutItems = `-- name: GetCheckoutItems :many
SELECT g.id         AS gundam_id,
       g.name       AS gundam_name,
       g.price      AS gundam_price,
       gi.url       AS gundam_image_url,
       s.id         AS seller_id,
       s.full_name  AS seller_name,
       s.avatar_url AS seller_avatar_url
FROM gundams g
         JOIN users s ON g.owner_id = s.id
         JOIN gundam_images gi ON gi.gundam_id = g.id
    AND gi.is_primary = true
WHERE g.id = ANY($1::int8[])
`

type GetCheckoutItemsRow struct {
	GundamID        int64       `json:"gundam_id"`
	GundamName      string      `json:"gundam_name"`
	GundamPrice     int64       `json:"gundam_price"`
	GundamImageUrl  string      `json:"gundam_image_url"`
	SellerID        string      `json:"seller_id"`
	SellerName      pgtype.Text `extensions:"x-nullable" json:"seller_name"`
	SellerAvatarUrl pgtype.Text `extensions:"x-nullable" json:"seller_avatar_url"`
}

func (q *Queries) GetCheckoutItems(ctx context.Context, itemIds []int64) ([]GetCheckoutItemsRow, error) {
	rows, err := q.db.Query(ctx, getCheckoutItems, itemIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCheckoutItemsRow{}
	for rows.Next() {
		var i GetCheckoutItemsRow
		if err := rows.Scan(
			&i.GundamID,
			&i.GundamName,
			&i.GundamPrice,
			&i.GundamImageUrl,
			&i.SellerID,
			&i.SellerName,
			&i.SellerAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
